Step 2: map JSON to model with Reads
======================================

## Generated Reads

### Bundled Reads
Sometime, life is easy. Play JSON comes with all needed implicits to read
 - Boolean (from JsBoolean)
 - String (from JsString)
 - Int, Long, Float, Double, BigDecimal (from JsNumber)
 - null (from JsNull)
 - Option (`Some(x)`for any JsValue if you have a Reads for `x`, `None` if null/absent)
 - Array, Seq (from JsArray)
 - \*Date, \*DateTime (you can use existing formater or use your own pattern from JsString) 

So thats why `(__ \ "name").validate[String]` is always compiling (for example).

### Semi-automatic Reads
If your model has only supported attribute types, you have can get a `Reads` for that type nearly for free.

```scala
import import play.api.libs.json._
implicit val MyClassReads: Reads[MyClass] = Json.reads[MyClass]
``` 

Be aware that the above macro ask for some implicits. If all attributes are already supported, you have nothing more to do. But if your model depending on another model, you must have its Reads in implicit scope.

```scala
//Your model
case class Dog(name: String, age: Int, preferedToy: Toy)
case class Toy(name: String, price: BigDecimal)
```
```scala
import play.api.libs.json._
//You have this one for free because Reads[String] and Reads[Int] are provided by play json
implicit val ToyReads: Reads[Toy] = Json.reads[Toy]
//The following needs the above implicit Reads[Toy], or it won't compile:
implicit val DogReads: Reads[Dog] = Json.reads[Dog]
```

See [JSON automated mapping](https://www.playframework.com/documentation/2.7.x/ScalaJsonAutomated#JSON-automated-mapping)

### About macros and implicits

In an application, you may use a lot of Reads. Because a good part of them will be generated by macro, and because these macros are generated in the order they are read by the compiler, you *must* already have an implicit `Reads[X]` in the scope at the line you define `Reads[Y]` if Y model depends on X.
Said otherwise, you must write your `Reads` with no dependency first, and dependants `Reads afterward.

Take the former example:
```scala
import play.api.libs.json._

implicit val ToyReads: Reads[Toy] = Json.reads[Toy]
//The following compile because Json.reads[Toy] macro is already defined at this point
implicit val DogReads: Reads[Dog] = Json.reads[Dog]
```
```scala
import play.api.libs.json._
/* NOT COMPILING because when the compiler generates Json.reads[Dog] macro,
 Json.reads[Toy] has not been generated thus the needed implicit Reads[Toy] is not defined !
 */
implicit val DogReads: Reads[Dog] = Json.reads[Dog]
implicit val ToyReads: Reads[Toy] = Json.reads[Toy]

```

## Custom Reads
See [value to model](https://www.playframework.com/documentation/2.7.x/ScalaJson#JsValue-to-a-model) and [Reads](https://www.playframework.com/documentation/2.7.x/ScalaJsonCombinators#Reads)

As you can see, you 
 
 - create path request and call the `read` method of the created `JsPath` to create a Reads for the type of the attribute in your model that maps to this path.
 - combine all these Reads with `and` from `play.api.libs.functional.syntax._`
 - get a `FunctionalBuilder[Reads]` that needs a function taking all elements of the type of your Reads and giving an instance of the model. Hence the reference to the `apply` method of your model's companion object.
 - get a Reads of the model returned by the `FunctionalBuilder`

The whole is a function that returns the Reads instance 
 
## Add constraints on reads values

See [validation with Reads](https://www.playframework.com/documentation/2.7.x/ScalaJsonCombinators#Validation-with-Reads)

## Exercise

Complete TODOs 2.x in the followings:

 - [`models.Invoice`](../src/main/scala/models/Invoice.scala) 
 - [`models.Film`](../src/main/scala/models/Film.scala)
 - [`models.FilmType`](../src/main/scala/models/FilmType.scala)
 - [`models.FilmEvent`](../src/main/scala/models/FilmEvent.scala)
 - [`models.Customer`](../src/main/scala/models/Customer.scala)
 
These tests about Reads must pass in tje following test suites:

 - [`Step2_ReadsSpec`](../src/test/scala/service/Step2_ReadsSpec.scala)
 - [`InvoiceSpec`](../src/test/scala/models/InvoiceSpec.scala)
 - [`FilmSpec`](../src/test/scala/models/FilmSpec.scala)
 - [`FilmEventSpec`](../src/test/scala/models/FilmEventSpec.scala)
 - [`CustomerSpec`](../src/test/scala/models/CustomerSpec.scala)


## Next

Checkout Step3 and go to [Step3: Writes](./Step3.md)
