Step 2: map JSON to model with Reads
======================================

## Generated Reads

### Bundled Reads
Sometime, life is easy. Play JSON comes with all needed implicits to read
 - Boolean (from JsBoolean)
 - String (from JsString)
 - Int, Long, Float, Double, BigDecimal (from JsNumber)
 - null (from JsNull)
 - Option (`Some(x)`for any JsValue if you have a Reads for `x`, `None` if null/absent)
 - Array, Seq (from JsArray)
 - \*Date, \*DateTime (you can use existing formater or use your own pattern from JsString) 

So thats why `(__ \ "name").validate[String]` is always compiling (for example).

### Semi-automatic Reads
If your model has only attributes of supported types, you have can get a `Reads` for your model's type nearly for free.

```scala
import import play.api.libs.json._
implicit val MyClassReads: Reads[MyClass] = Json.reads[MyClass]
``` 

Be aware that the above macro ask for some implicits. If all attribute types are already supported, you have nothing more to do. But if your model is depending on another model, you must have its Reads in implicit scope.

```scala
//Your model
case class Dog(name: String, age: Int, favoriteToy: Toy)
case class Toy(name: String, price: BigDecimal)
```
```scala
import play.api.libs.json._
//You have this one for free because Reads[String] and Reads[Int] are provided by Play JSON
implicit val ToyReads: Reads[Toy] = Json.reads[Toy]
//The following needs the above implicit Reads[Toy], or it won't compile:
implicit val DogReads: Reads[Dog] = Json.reads[Dog]
```

See [JSON automated mapping](https://www.playframework.com/documentation/2.7.x/ScalaJsonAutomated#JSON-automated-mapping)

### About macros and implicits

In an application, you may use a lot of Reads. Because a good part of them will be generated by macro, and because these macros are generated in the order they are read by the compiler, you *must* already have an implicit `Reads[X]` in the scope at the line you define `Reads[Y]` if Y model depends on X.
Said otherwise, you must write your `Reads` with no dependency first, and dependants `Reads` afterward.

Take the former example:
```scala
import play.api.libs.json._

implicit val ToyReads: Reads[Toy] = Json.reads[Toy]
//The following compile because Json.reads[Toy] macro is already defined at this point
implicit val DogReads: Reads[Dog] = Json.reads[Dog]
```
```scala
import play.api.libs.json._
/* NOT COMPILING because when the compiler generates Json.reads[Dog] macro,
 Json.reads[Toy] has not been generated thus the needed implicit Reads[Toy] is not defined !
 */
implicit val DogReads: Reads[Dog] = Json.reads[Dog]
implicit val ToyReads: Reads[Toy] = Json.reads[Toy]

```

## Custom Reads
See [value to model](https://www.playframework.com/documentation/2.7.x/ScalaJson#JsValue-to-a-model) and [Reads](https://www.playframework.com/documentation/2.7.x/ScalaJsonCombinators#Reads)

As you can see, you 
 
 - create path request and call the `read` method of the created `JsPath` to create a Reads for the type of the attribute in your model that maps to this path.
 - combine all these Reads with `and` from `play.api.libs.functional.syntax._`
Then,
 - this gives you a `FunctionalBuilder[Reads]#CanBuildN[T1, ..., Tn]` with `N` being the number of attributes combined with `and` and `Tn` the respective types of these arguments. Ugly monster ? No big deal, because this is just a hidden thing that ask for a function taking `N` arguments of all `Tn` types types as arguments and giving an instance of the model. And you already have this function: this is the `apply` method of your model's companion object.

The result is a function that returns the Reads instance.
 
## Add constraints on reads values

See [validation with Reads](https://www.playframework.com/documentation/2.7.x/ScalaJsonCombinators#Validation-with-Reads)

## Exercise

Complete TODOs 2.x in the followings:

 - [`models.Invoice`](../src/main/scala/models/Invoice.scala) 
 - [`models.Movie`](../src/main/scala/models/Movie.scala)
 - [`models.MovieType`](../src/main/scala/models/MovieType.scala)
 - [`models.MovieEvent`](../src/main/scala/models/MovieEvent.scala)
 - [`models.Customer`](../src/main/scala/models/Customer.scala)
 
Tests about Reads must pass in the following test suites:

 - [`Step2_ReadsSpec`](../src/test/scala/service/Step2_ReadsSpec.scala)
 - [`InvoiceSpec`](../src/test/scala/models/InvoiceSpec.scala)
 - [`MovieSpec`](../src/test/scala/models/MovieSpec.scala)
 - [`MovieEventSpec`](../src/test/scala/models/MovieEventSpec.scala)
 - [`CustomerSpec`](../src/test/scala/models/CustomerSpec.scala)


## Next

Checkout Step3 and go to [Step3: Writes](./Step3.md)
